<?php

/**
 * －－－－－－－－－－－－
 *后台内容管理:
 * －－－－－－－－－－－－－
 */
class ContentController extends BaseController{

	/**
	 * 构造函数：验证登陆,token
	 */
	public function __construct()
	{
		$this->beforeFilter('auth');
		//上传数据总是设定一个隐藏token,传过来后则要验证.
		$this->beforeFilter('csrf',array('only'=>array('postAdd','postEdit')));
	}

	/**
	 * ＊显示内容管理主页面＊：
	 * 			该页面包括添加内容以及内容列表
	 * 		
	 *说明下这里的页面显示流程:
	 *		后台左边栏是多个li组成的下拉框->点击时,触发js,通过js得到写在那个li上的分类id
	 *		->然后js更改iframe的src为下面这个方法的对应route.
	 *			[后台的主内容页面都是放在同一个iframe里面,通过改它的src来实现页面改变]
	 *		->然后这个id就传入下面这个方法->处理完之后返回一个页面给iframe->显示页面
	 *		
	 *		--------------------------------------------------------------
	 *		这个方法体现出分类和内容的关系具体是怎么实现的.
	 *		最主要的一条就是查询所有子分类过去,为新添内容确定分类.其他的则视具体需求而定.
	 *  	---------------------------------------------------------------
	 *  	
	 * @参数  ①$id 	这个id是顶级分类id.用于区分需要哪个大类的管理页面，将显示整个分类的内容,
	 *         			比如新闻大类,然后下面包括的军事新闻,新闻评论等都会出现在内容列表.
	 * 			        	---这种情况发生在点击后台页面的左边栏选择内容管理页面的时候.此时传进顶级分类id
	 * 			        	
	 *@ajax接收的数据     ①$cid:	
	 *							这个id是子类的id.	不一定会有.
	 *         					现在的构想是,给一个select选框,里面包含大类中的子类,可以通过选择对应的子类,让列表只显示对应的子类内容.
	 *         			  		这个会在用户改变select选择项时,通过js获得放在select的option上的value.然后再传入该方法.
	 *
	 *					②timeOrder:
	 *							如果ajax传过来这个参数,则表示需要按时间排序.有两个值:
	 *								1,代表越新的内容越靠前.
	 *								2,代表越老的内容越靠前
	 *
	 * 					注:	其实真正做的时候上面两个并非通过ajax传进来,因为不管怎么排序,最后都是返回页面.
	 * 						----------------------------------------------------------------
	 * 						如果用ajax来做,那返回的页面就到ajax回调函数那去了.然后还要自己处理放到页面上,很复杂.
	 * 						这里是直接通过改iframe这个内容容器的src,来传入参数的,通过这种写法:
	 * 						--------------------------------------------
	 * 							http://cms/admin/content/index/方法参数?cid='xx'...
	 * 						这样的get传参写法,除了一个本身控制器方法必须的参数外,其他的参数是通过Input::get()获取的
	 * 						--------------------------------------------------------------------------
	 *
	 * @搜索操作传来的数据	有必要解释一下:这个数据既不是通过方法参数传来的,也不是ajax传来的,而是通过form表单传来的.
	 * 																		-----------------------	
	 * 					但同样是用Input::get()来获取,而不是作为方法参数,
	 * 					-----------------------------------------
	 * 					它的参数有:
	 * 						①category_id:	
	 * 								隐藏input传来的数据,作为标识,以区分正常显示页面还是搜索之后的页面.
	 * 					   			-------------------------------------------------------
	 * 					   ②newsSearch:
	 * 					   			对应搜索文本框
	 * 					   			
	 * 					   ③newProperty:
	 * 					   			搜索文本绑定的字段,比如title字段=输入文本.也有一个选项是不限字段,那就是所有字段都去匹配
	 * 					   
	 * 					   ④range:
	 * 					   			匹配某个时间范围,比如查看2天内的数据,半年内的数据等.
	 */					
	public function getIndex($id){
		//当前顶级分类.
		//	解释下这个分类id在页面上的用处,后台内容管理"添加内容"页面是一个js控制的选项卡的效果
		//	它有一个li包含一个a标签,a标签的href对应包含内容的div的id,
		//	也就是说,只要href和div的id相同,则会让这一块显示.否则不显示.
		//	我这里就是利用这个效果.把所有分类比如新闻,商城等的内容添加都写在这个页面,但默认是隐藏.
		//	通过改a标签的href来决定哪个div显示.
		//	href的话把这个分类id拼接上去,就具有动态效果了.
		//	而内容div上也就得有对应的html id,也可以用它自身的分类id连上去.那样就和上面的href产生关联.
		//	但是有一个问题,就是id是非常易变的,只要删除一次,再添加,id就不同了.
		//	所以内容div用id来拼接它的html id不靠谱.
		//	不变的字段几乎没有,唯一好一点的就是relation字段.那个是对应内容表的表名.
		//							--------------
		//	在添加顶级分类时必须要选择一个对应的内容表.这个字段一般来说不会改.
		//	所以用这个relation字段来拼接到div的html id上面,而href也用这个.
		//	这个可以写死在html上,因为比如这个是新闻添加内容的div,那它固定就是添加新闻的,添加商城的就完全不同的内容了.所以写死.
		//	但每次传到选项卡的relation可是动态的.要查一下.直接带到页面去.

		/*[后加] 不管什么排序和条件,默认的情况,都应该以最新的数据在前面,否则添加一条数据,总数据多的时候还找不到*/

		//得到的id为顶级分类id，需要将它所有子类数据全部传送过去．
			$top=Category::find($id);
		//顶级分类名称，用作标题
			$title=$top->category_name;
		//relation字段,对应的内容表
			$relation=$top->relation;
		//所有可写的子类(最终类)
		//-----------------
			$child=Category::whereRaw("path like '$top->path$id%' and final=1")->get();
			//这个可能会出现没有子类的情况.
			if(!count($child)){
				$msg='没有子类,没有内容,需要先添加最终子类,请选择"分类管理"->"管理分类"->"分类列表"->"添加子类"->然后再添加内容';
				//这种情况下,内容列表,或者添加内容都不能操作.因为都没有可写子类,怎么往里面添加内容?
				//所以直接返回就是了.
				return $msg;
			}

		//----------------------------------------------------------------------------------------
		//查询当前顶级分类对应的内容表的所有内容.
		//注意,我的设定中,分类表和内容表是一对多的关系.
		//所以可以用hasMany的方法来查内容表的数据.
		//它需要一个model类hasMany方法的方法名,
		//而这个方法名,也就是记录在分类表中的relation,内容表表名.	[注意,因为有这样的逻辑存在,所以添加relation字段时需要注意保持一致]
		//但是有一点要注意,必须是可写的分类才有内容.也就是说,只有最终类才有对应的内容,
		//所以应该以最终子类来对应查找内容.
		//这样的话,用一对多的专用写法就要查多次,每次查一个对应的id,如:Category::find(21)->news()->get();要查很多个id的对应项
		//就不如直接用普通逻辑来做了,得出所有可写子类的类id,然后一次性的去内容表查出所有内容	[用'in'操作]
		//-------------------------------------------------------------------------------------------
		
		//按照上面所讲的思路,先将所有可写子类的id拼成一个数组,以便做in操作.注意,laravel的whereIn是拼成数组,如果原始的做法,是拼成(1,2,3)的形式
		//				--------------------------------------------------------------------------------------------------
		//另外页面内容列表上显示分类id是没有意义的,应该改成文字的category_name.
		//		-----------------------------------------------------
		//那么这里还需要拼接一个数组,以分类id为键,分类名为值.那样的话,在循环内容表的内容时,可以很方便的用category_id找到category_name
		//-----------------------------------------------------------------------------------------------------------
			foreach($child as $v){
				$all_id[]=$v->id;
				$find_name[$v->id]=$v->category_name;
			}
		

		/**
		 * 除了初始页面,其他的显示页面是三种独立的情况:
		 * 		①改变时间排序:最早或者最新排在前面.
		 * 		②只显示某一个子类的内容
		 * 		③搜索:
		 * 	 	因为三个是独立的请求,所以这边也就可以独立判断,
		 * 	 	-------------------------------------
		 * 	 	另外所有判断,其实都只是针对内容,$content一个变量.其他变量是不需要改变的.
		 * 	 	------------------------------------------------------------
		 * 	 	所以return最终显示页面的语句可以放到所有判断之后.避免重复累赘.
		 * 	 	---------------------------------------------------
		 */
			
		//1,需要按时间排序的情况
		if($time=Input::get('timeOrder')){
				//查询内容表
				//因为是一对多,这里有个非常方便之处,就是所有内容表的外键都是category_id,那么这里的查询代码就可以通用了.
				//另外事实证明query builder比Eloquent更灵活.此时并不知道具体是哪个内容表.Eloquent就没法用了.
				//			--------------------------------------------------------------------
				//内容列表是需要分页的.所以用paginate.涉及排序,用obderBy
				//------------------------------------------------
				
				//按时间最新的排
				if($time==1){
					try{
						$content=DB::table($relation)->whereIn('category_id',$all_id)->orderBy('created_at','desc')->paginate(20);	
					}catch(\Exception $e){
						Log::error($e->getMessage());
						//数据库查询失败,现在测试基本上都是根本没有内容表造成的.
						return '数据库查询错误!查看是否有对应内容表!!';
					}

					//追加分页的条件.因为根据分页的原理,如果点选某个页码,它是还要回来这个方法的,然后重新查找符合条件的内容.
					//现在要将该排序条件,追加到模板上的分页方法上$content->appends(array('timeOrder'=>1)->links())
					//这样写的话,下次改变页面,它再回来时,还会带着那个timeOrder参数进来,以同样的限制条件进行查找内容.
					//否则,不把参数带过去,那边改变页面时回来,在这个方法中就判断为查找全部了.跟想要的不一样.
					//$timeOrder=1; 其实这里不用重复写了,所有这些条件变量with的时候都带过去就好了.值就是现在获取的值,
					//记得加错误抑制符,如果没有这个变量也不会报错.
				
				}else{
					//按最旧的排
					try{
						$content=DB::table($relation)->whereIn('category_id',$all_id)->orderBy('created_at')->paginate(20);
					}catch(\Exception $e){
						Log::error($e->getMessage());
						//数据库查询失败,现在测试基本上都是根本没有内容表造成的.
						return '数据库查询错误!查看是否有对应内容表!!';
					}
				}
				//如果查询结果中没有内容,是不会报错的.只是没结果.此时就让内容列表空着就行了.给个说明信息
					if(!count($content)){
						$msg='此类下尚无内容!选择"添加内容"模块进行添加';
					}else{
						$msg='';
					}
				
		//2,当有"只显示某一子类"选项时,即ajax传过来cid参数时.只需要显示一个子类的内容
		}elseif($cid=Input::get('cid')){
			//该cid也就是内容表的category_id,那么对应该category_id的数据才显示
			//那么就不需要whereIn了,直接where判断就行了.
			try{
				$content=DB::table($relation)->where('category_id',$cid)->orderBy('updated_at','desc')->paginate(20);
			}catch(\Exception $e){
				//一样的出错,返回错误信息
				Log::error($e->getMessage());
				//如果查询数据库都失败,也就根本没有$content变量,没有内容可显了.直接返回错误.
				return '数据库查询错误!';
			}

			//查询不报错,但有可能没有内容
			if(!count($content)){
				$msg='此类下尚无内容!选择"添加内容"模块进行添加';
			}else{
				//之所以还要加一个空,就是下面return页面的语句避免写多个.不管msg内容是什么,反正有这个变量,
				//-------------------------------------------------------------------------
				//那么return语句就可以只写一句,否则就得写两句,一句有msg,一句没有.
				//具体msg什么内容,前台可以判断一下.
				//----------------------------
				$msg='';

				//因为laravel的分页都是针对普通情况来查询的,也就是说,它只带有这个方法本身的那个参数,
				//其他的查询条件,或者时间排序这些,它都是没有的.所以应该自己带过去,增加它的分页条件.
				//所以现在这个时候应该将cid传回到模板,然后模板再用$content->appends(array('cid'=>$cid))->links()
				//这样的写法来追加条件.否则的话每次搜索就第一页是按搜索条件来的,下面的分页又是全部内容了.
				//这个不用在这里给赋值了,因为有的话,上面已经赋值过了,只要with过去就行了.			
			}

		//3,当有搜索的时候.应该注意:搜索是各个版块不一样的,比如商城和新闻就是不同的.
		//						------------------
		//这个可以通过方法的参数$id来判断.因为form再次调用到这个方法时,还是得传一个$id进来.
		//--------------------------------------------------------------------
		//通过这个就可以知道当前是哪个顶级分类,或者换个名词,版块.
		//但是这样的话,搜索form表单调用该方法,和初始化页面调用该方法,参数是一样的,
		//--------------------------------------------------------------
		//要怎样区分?就还得需要一个标识符.表明是搜索.这个放在form表单的input:hidden里面,
		//其实有下面这些Input::get的任何变量也可以区分了,初始化页面是没这些的,但是那些不一定有,给个固定标识更好判断
		//----------------------------------------------------------------------------------------------------------------------------
		
		}elseif($category_id=Input::get("category_id")){
			//category_id就是隐藏字段,用来做标识,对应的也确实是顶级分类id,其实和方法参数$id是一样的.
			//这里我就只用$id好了.

			//这里先必须查一下初始的内容结果集,保存为$content_keeper.如果搜索有结果$content,那么直接用$content,如果没结果,还得用这个数据$content_keeper
			//-------------------------------------------------------------------------------------------------------------------------
			//这里就不用try/catch了,因为搜索的时候已经有页面显示,表示肯定有内容.
			$content_keeper=DB::table($relation)->whereIn('category_id',$all_id)->orderBy('updated_at','desc')->paginate(20);

			//有一个原始条件,不管搜索什么都得带上.就是显示初始页面的条件,所以可以开始就先写好:
			//-----------------------------------------------------------------
			//用原生的sql语句,需要将id数组拼接一下,成为类似(1,3,4)这样的结果.
			//------------------------------------------------------
			$str='(';
			foreach($all_id as $v){
				$str.=$v.',';
			}
			//出了循环之后,肯定右边多了一个',',得trim掉
			$str=rtrim($str,',').')';
			//放到where条件里面
			$where="category_id in $str";

			//a:首先得判断是哪个版块,顶级分类的数据是有一个内容表关联的字段relation.上面已经查出来了.
			
			//＊①新闻＊	的搜索有三个限制条件:
			//							输入的文本				---->可能匹配title,content也可能匹配任意字段
			//							查某一个对应字段.			---->这个就是输入文本的限定字段,	
			//							查多少时间内的数据,		
			if($relation=='news'){
				//这里把查询条件拼接一下,代码比较简洁,首先不管其他条件有没有,
				//本身这里输出有个限制条件,那就是都是指定顶级分类的子类的内容才要,
				//所以必须有一个category_id in匹配.
				//如果是要自己重新完整的写,则必须把上面的$all_id处理一下,拼接成(1,2,3)这样的格式.

				//A,对于搜索来说,搜索框的文本肯定是首要的.如果没有填,直接就返回
				if(!Input::has('newsSearch')){
					$msg=2;								//这个错误就不要报了.	
					return View::make('admin/content')->with('child',$child)
													->with('title',$title)
													->with('id',$id)
													->with('relation',$relation)
													->with('find_name',$find_name)
													->with('msg',$msg)
													->with('content',$content_keeper)
													->with('id',$id);				
				}else{	
					$text=Input::get('newsSearch');		//得到文本
					//B,有文本内容的时候,那么,首先看有没有约束字段,因为这两者是紧密联系的.
					if(!Input::get('newProperty')){
						
						//没有,那么就是在所有字段匹配了
						//因为这个news表的title,content,author字段加了全文搜索的索引,所以这几个用match()against()来查
						//然后再连接上其他的条件,
						//另外用like模糊匹配,扩大一些搜索范围.
						//------------------------------
						$where.=" and match(title,author,content) against('$text*' in boolean mode) or created_at regexp '.*$text.*' or updated_at regexp '.*$text.*'";
					}else{
						//有限定字段就更简单了
						$field=Input::get('newProperty');
						//条件字符串:	字段是不需要引号的,其他字符串需要
						//---------------------------------------
						$where.=" and $field like '%$text%'";
					}

					//C,有时间范围的情况
					if($range=Input::get('range')){
						//查多少时间内的数据
						/**
						 * 这个就有很多类型了,这是个select,对应的值如下:
						 * 		①"1":		1天内的数据
						 * 		②"2":		2天内的数据
						 * 		③"7":		1星期内的数据
						 * 		④"30":		1个月内的数据
						 * 		⑤"180":		半年内的数据
						 * 		
						 * 	这里应该写一个函数,因为很多版块都会有根据发布信息时间来排序.
						 * 	这个函数的作用不复杂,就是批量处理时间,比如这里有5种情况,
						 * 	-------------------------------------------------
						 * 	如果每种都自己写求时间的代码,代码将非常多.写个函数,将这些时间全传进去,返回一个数组,比较方便.
						 * 	------------------------------------------------------------------------------
						 */
						
						//下面对应来处理各种时间
						//①当天的时间可以先得出来
						$now=date('Y-m-d');		//返回如'2014-07-01'

						//除了当天的时间,其他的,全部带入到时间函数里面去,返回一个需要的目标date
						//因为那个函数需要的是天数,所以特意调整了一下模板上select的value,换成对应天数.
						//那么这里直接带进去函数就行了.
						//因为这个在模板上是固定的查这几个,所以直接写死就行了.注意,比如2天内,那么目标date是今天的一天前开始,所以这些数字都要减1.
						//思路是between 目标date and 当前date 这样来查范围.
						//---------------------------------------------
						$all_days=array(1,6,29,179);				
						$target_date=ReturnDate::doit($all_days);	//返回的是数组,对应所有的目标date	

						//用switch/case来匹配各种情况,这里要拼接的是查询条件
						//--------------------------------------------
						switch ($range) {
							case '1':
								//也就是当天的,直接用当天时间去匹配就行了.mysql里面用date函数取出年月日部分
								//-------------------------------------------------------------
								//拼接条件语句,这个是连上上面的.
								$where.="and date(updated_at)='$now'";
								break;

								//下面的几种都是有一个时间范围的,所以要用between and.注意,$target_date里面的时间更早,应该放在前面
								//----------------------------------------------------------------------------------
								//还有and前面既然还有语句,应该留一个空格,使格式更正规.
								//------------------------------------------
							case '2':
								$where.=" and date(updated_at) between '$target_date[0]' and '$now'";
								break;
							case '7':
								$where.=" and date(updated_at) between '$target_date[1]' and '$now'";
								break;
							case '30':
								$where.="and date(updated_at) between '$target_date[2]' and '$now'";
								break;
							case '180':
								$where.="and date(updated_at) between '$target_date[3]' and '$now'";
								break;
							default:
								// 注意,这里已经没什么好写了,直接跳出就是了
								// -----------------------------------
								break;
						}
					}
				}
				//到这里,所有条件都拼接完了,就可以到数据库去查询了..
				try{
					$content=DB::table($relation)->whereRaw($where)->orderBy('updated_at','desc')->paginate(20);
				}catch(\Exception $e){
					Log::error($e->getMessage());
					//这是个搜索查询,所以很有可能随便输点什么过来,那么查不到东西也是很平常的.
					//查不到东西的时候,直接返回初始的内容页面过去就好了
					//----------------------------------------
					//前面已经保存了一下原始的内容结果集$content_keeper
					//注意,这里为了避免重复写return语句,这里给$content赋予一个真正有用的内容结果集到下面一起返回
					//----------------------------------------------------------------------------
					$content=$content_keeper;
					$msg=2;					//搜索的msg错误信息给个比较好识别的数据,前台错误报告碰到这个错误编号就不要报错了,因为搜索的错误的机会太多了.
				}	
				//同样的,没有结果也直接返回原页面
				if(!count($content)){
					$content=$content_keeper;
					$msg=2;
				}
			}
			


		//完全没有限制条件的情况,也就是初始生成内容页面,查询所有数据
		}else{
			try{
				$content=DB::table($relation)->whereIn('category_id',$all_id)->orderBy('updated_at','desc')->paginate(20);
			}catch(\Exception $e){
				Log::error($e->getMessage());
				//数据库查询失败,现在测试基本上都是根本没有内容表造成的.
				return '数据库查询错误!查看是否有对应内容表!!';
			}
			//查询不报错,但有可能没有内容
			//----------------------
			if(!count($content)){
				$msg='此类下尚无内容!选择"添加内容"模块进行添加';
			}else{
				//之所以还要加一个空,就是下面return页面的语句避免写多个.不管msg内容是什么,反正有这个变量,
				//------------------------------------------------------------------------
				//那么return语句就可以只写一句,否则就得写两句,一句有msg,一句没有.
				//具体msg什么内容,前台可以判断一下.
				$msg='';
			}
		}
		
		//为了匹配下面的return语句,没有错误信息,为空就行了.
		if(!@$msg){
			$msg='';
		}

		

		//最终显示页面
		return View::make('admin/content')->with('child',$child)
										->with('title',$title)
										->with('relation',$relation)
										->with('find_name',$find_name)
										->with('msg',$msg)
										->with('content',$content)
										->with('id',$id)					//分类id当ajax回传这个方法时需要用到
										->with('timeOrder',@$timeOrder)		//以下这几个都是搜索或者排序的条件,传给模板分页,下次带回来,以保持这个条件
										->with('cid',@$cid)
										->with('category_id',@$category_id)
										->with('newsSearch',@$text)
										->with('newProperty',@$field)
										->with('range',@$range);
	}
										
	//处理新闻内容上传
	public function postAdd($id){
		//接收数据,除去图片和token
		$add['title']=Input::get('title');									//标题
		$add['content']=mysql_real_escape_string(Input::get('content'));	//内容,编辑器的内容带有很多空格标签等.
		
		//验证规则
		$rule=array('title'=>'required','content'=>'required');
		//验证:
			$validator=Validator::make($add,$rule);
			if($validator->fails()){
				//验证失败,返回错误信息,这个id是顶级分类id.上面方法放进到模板上的,模板又带到这里.
				//然后现在返回去,就将它带回去.
				return Redirect::to("admin/content/index/$id")->withErrors($validator);
			}

		//验证成功之后,将数据添加数据库
		//category_id就是页面上下拉选框的options value值,生成页面时已放上去.
		//对应的是目前需要添加内容的分类id
		$add['category_id']=Input::get('category');
		$add['author']=Input::get('author');						//作者

		//既然用了ckeditor编辑器,就用它来选择图片.不需要图片上传了.
		//将现在这些数据写入数据库就行了.
		//因为Category表和news表是一对多的关系.所以直接用它的专门方法来写
		//------------------------------------------------------
		$news=new News($add);	
		$category=Category::find($add['category_id']);
		$bool=$category->news()->save($news);
		
		//返回成功信息
		$msg='添加成功!';
		return 	Redirect::to("admin/content/index/$id")->with('msg',$msg);			
	}

	/**
	 * ＊编辑新闻内容[页面]＊
	 * 			说明下,这个编辑内容页面,是由js控制showModalDialog生成一个新窗口来调用这个url
	 *
	 * @参数:	
	 * 			$id:	对应的那条内容的id
	 */
	public function getEdit($id){
		//查询该条数据,这里不做数据库错误的判断,因为它是从内容列表过来的,肯定是有数据的.
		$news=News::find($id);

		//显示页面之前看下有没有编辑"操作"页面转过来的错误信息.有的话也得带到页面上去
		//-------------------------------------------
		//为了让变量统一,不管有没有这个msg变量都同一条return,那么在没有$msg的时候也给它赋一个空.
		//-------------------------------------------------------------------------
		if(Session::has('msg')){
			$msg=Session::get('msg');
		}else{
			$msg='';
		}

		//显示页面
		return View::make('admin/editContent')->with('news',$news)
												->with('id',$id)		//id也要带过去,因为等下要传到编辑操作页面.	
												->with('msg',$msg);
	}
	

	/**
	 * ＊编辑新闻内容[操作]＊
	 *
	 * 说明:		所有分类的内容显示页面都是写在一起的,一个方法,一个页面.
	 * 			不过处理编辑内容,还是分开来写.否则一个方法里写的太复杂.
	 *
	 * @参数:	
	 * 			①$id 	对应内容表的id.----改和删都是需要id的,这是常识
	 * 					只需要一个参数,其他都是form表单传过来,Input::get来接收
	 */
	public function postEdit($id){
	//1,接收数据
		//接收所有,除了token
		$data=Input::except('_token');
		
	//2,验证数据,需要验证的,只有title,content必须填,其他没什么了.
		//拼接规则
		$rule=array('title'=>'required','content'=>'required');
		//验证
		$validator=Validator::make($data,$rule);
		//失败返回错误信息
		if($validator->fails()){
			$messages=$validator->messages();
			//只取一条,用js来报错,有一个错就行了,反正都不能通过
			$msg=$messages->all()[0];
			//返回到显示页面
			return Redirect::to('admin/content/edit/'.$id)->with('msg',$msg);
		}

	//3,写入数据库
		//因为这个是专门做新闻编辑的方法,所以表是确定的.
		try{
			News::where('id',$id)->update($data);	
		}catch(\Exception $e){
			Log::error($e->getMessage());
			//出错的话,可以返回下query log以供查看
			$query=DB::getQueryLog();
			$last=end($query);					//数组,得到最后一条.
			//返回显示页面,注意,这里with的时候还是用msg的变量名,减少显示方法的判断代码,
			//			---------------------------------------------------	
			//反正所有错误都是独立的.不会丢失掉某个错误信息.
			//-------------------------------------
			return Redirect::to('admin/content/edit/'.$id)->with('msg',$last);
		}

	//4,操作全部完成之后,返回成功信息.
		return Redirect::to('admin/content/edit/'.$id)->with('msg','修改成功!');
	}

	

	/**
	 * ＊[后加] 为新闻添加头条这个字段＊
	 * 
	 * 	说明:新闻头条是用在列表页,也就是新闻的首页,显示时如果有头条这个字段,
	 * 	那么会显示得不一样,第一显示在该版块的第一条,第二字体为粗体或者字体更大,以使其更加醒目
	 * 	根据现在的情况,新闻列表页,每个类有两个小版块,所以可以有两个头条.多个头条取最新的两个.
	 * 	当然添加时可以一并添加.取的时候取最后两个就行了.
	 *
	 * 	方法本身的参数:
	 * 		$id:	这个是新闻顶级分类id,其实并非本身需要用,而是当操作结束或者出错返回时,
	 * 				去显示页面需要这个id.	
	 * 
	 * 自己要用到的数据全是由form提交过来,可以接收到的数据如下:
	 * 
	 * 	①toutiaoLevel: 	是一个select选框,值为2,1,代表1级头条和2级头条,默认为0不头条.
	 * 	
	 * 	②tuijianLevel:	同样select选框,值为8-1,代表1-8级推荐,默认为0不推荐
	 * 						---我的设计中头条是上本类,如新闻类的首页,而且醒目显示
	 * 							而推荐则是上整个网站的首页.
	 *
	 *					－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
	 *     				注意上面的select默认值的安排,是后来经过再考虑得出的.原本默认不推荐/头条,值为0
	 *     				那么在输出时排序,就不好控制.因为推荐/头条的等级是数字越小,越优先输出.
	 *     				但如果不推荐值为0,那么就比1还小,在一条查询语句中排序,它更在一级头条前面.
	 *         			或者,为了不大规模更改数据库,可以将1级-8级用倒序.比如1级推荐,它的值为8.
	 *         			那么8-1-0,这样的优先级别也符合需求.
	 *         			应该选择后一种方式,因为只改推荐/头条那几个值,如果要改默认值,就所有数据都要改了.
	 * 					－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
	 * 							
	 * 	③content_id[]: 	这个是多选框,每一个对应当条数据的id. 	
	 *
	 * 	④action:		这个是js在表单提交时挂载到url上的参数,通过这个参数来判定是什么操作.
	 * 					它有两个值:
	 * 					toutiao:代表头条操作
	 *      			tuijian:代表推荐操作
	 * 
	 * 	注意:这里等于有两个操作,本来想用两个form分开来,但那个多选框是在整个table每一行都有.
	 * 	也就是说,为了取到这些多选框的值,必须form要套到整个table外面,如果两个form都要套这个table的话,不好安排.
	 * 	现在就是在模板上给出了两个submit,虽然都是同一个form,内容都还是会来这里.
	 * 	但通过js来确定点的是哪一个,从而判断是要进行什么操作.
	 */
	public function postNewsToutiao($id){
	//1,上面已经解释得很清楚,那么首先接收下数据,content_id是必须要有的,先接收,
	//这是个数组,复选框的name是写成content_id[]这样的数组格式.
		$content_id=Input::get('content_id');
		//这个是必须有的,如果没有,直接返回,没法操作
		if(!$content_id){
			//直接返回显示页面,并且报错
			return Redirect::to("admin/content/index/$id")->with('ttmsg','没有选择任何一条数据');
		}

	//2,判断是什么操作
		if(Input::get('action')=='toutiao'){
			//头条操作
			//A:看是几级头条,如果没有选择就传过来,也是没法操作的,直接返回
			$toutiao=Input::get('toutiaoLevel');
			if(!$toutiao){
				//这个还是给个错误信息吧
				return Redirect::to("admin/content/index/$id")->with('ttmsg','没有选择几级头条');
			}

			//B:其实新闻类只需要两个头条.而复选框可以选非常多个.
			//这样的话,为了以后便于输出,将以前的头条清除,再添加给新的数据.
			//但是这样的话,也是繁琐的操作,因为那模板那边可是不分类的提交过来.
			//既有国内新闻,也有国际新闻,军事..等等.
			//这样要挑出来,每个类只能有两个可以获得头条字段.可以做,但非常罗嗦.
			//而且后台也不是随便乱来的地方.如果不是头条,不会随便添加.现在就一起添加到数据库.
			//输出的时候按头条和更新时间排序.后面的头条最前.然后一级头条和二级头条只取一条就好了.
			//根据实际需求,不一定每天都会去加头条,如果当天没有头条的时候用最新的那条数据.
			
			//那么现在全部提交数据库
			try {
				News::whereIn('id',$content_id)->update(array('toutiao'=>$toutiao));
			} catch (\Exception $e) {
				Log::error($e->getMessage());
				return 	Redirect::to("admin/content/index/$id")->with('ttmsg','添加头条信息失败');		
			}

		}else{
			//只有两种情况,既然不是头条就是推荐了.
			//A:同样先判断,有没有选择几级推荐
			if(($tuijianLevel=Input::get('tuijianLevel'))==false){
				//直接返回
				return Redirect::to("admin/content/index/$id")->with('ttmsg','没有选择几级推荐');
			}
			//B:写入数据库
			try {
				News::whereIn('id',$content_id)->update(array('tuijian'=>$tuijianLevel));	
			} catch (\Exception $e) {
				Log::error($e->getMessage());
				return Redirect::to("admin/content/index/$id")->with('ttmsg','添加推荐信息出错!');
			}
		}

		//两种判断情况都做完,现在只要返回页面,并加上成功信息
		return Redirect::to("admin/content/index/$id")->with('ttmsg','设置成功!');		
	}

	/**
	 * ＊删除头条---[操作方法]＊
	 * 		它对应的显示方法是整个内容列表的显示方法.
	 * 	参数:
	 * 		①id:	内容id
	 * 		②top:	顶级分类id[用作回传显示方法需要的参数]
	 * 		③type:	值有两个:toutiao,tuijian.表明是进行哪个操作.
	 * 		
	 * 		这三个都是通过js传过来的.
	 */
	public function getDeleteNewsToutiao($id,$top,$type){
	//1,接收数据,这次是直接写在方法参数上,所以直接用
	//2,判断是什么操作.
		if($type=='toutiao'){
			//取消头条.注意,这个是点击的js时间,所以每次就只有一个取消.
			//操作数据库
			try {
				News::where('id',$id)->update(array('toutiao'=>0));
			} catch (\Exception $e) {
				Log::error($e->getMessage());
				//注意这个,这次不用ajax传,而是直接改iframe的src,所以return 是不会回js那边的.
				//那么这里要回显示方法.
				return Redirect::to("admin/content/index/$top")->with('ttmsg','数据库操作失败!');
			}
		}else{
			//只有两种情况,不是头条,就是推荐了.
			try {
				News::where('id',$id)->update(array('tuijian'=>0));
			} catch (\Exception $e) {
				Log::error($e->getMessage());
				return Redirect::to("admin/content/index/$top")->with('ttmsg','数据库操作失败!');
			}
		}

		//操作成功之后,也是返回显示方法,并说明成功信息
		return Redirect::to('admin/content/index/'.$top)->with('ttmsg','取消成功!');
		
	}


	/**
	 * ＊删除新闻内容＊
	 *
	 * @参数:
	 * 		$id 	对应内容数据的id
	 *   			同样是js传一个id过来,删掉就完了.
	 * 		
	 */
	public function postDelete($id){
		//直接删除
		try{
			News::destroy($id);
		}catch(\Exception $e){
			Log::error($e->getMessage());
			//返回错误信息
			return '删除失败!';							
		}
		//因为还要返回ajax回调函数,所以用简单点,易判断的信息代表成功
		//------------------------------------------------
		return 1;
	}
}